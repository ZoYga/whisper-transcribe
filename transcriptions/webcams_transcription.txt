 доброе утро и так я решил что в эту лекцию мы также светим разбору неких примеров часть примеров будут похожи на задачу номер пять который вас встречается ну и может быть разберем задачу номер шесть а уже чтобы большинство из вас отставала у практика макк лекции на минимальное расстояние уже тогда на следующей лекции перейдем к новой теме массивом так и тем более до что на прошлой лекции мы с вами все примеры не рассмотрели и остановились мы с вами вот на таком примере то есть нам нужно нарисовать вот такую фигурку заданную высотой шириной где высота и ширина у нас больше либо равно трем и вот нужно придумать как без применения естественно массивов такую фигуру нарисовать так смотрите как мы сейчас с вами будем рассуждать так единственное конечно вас тона акс зачем смолит она мне здесь где то есть значит во многих задачах для того чтобы эта задача решалась легко и просто ну во всяком случае легче чем возможные другие варианты нужно найти правильную модель как меня слышно если что да значит нужно найти правильную модель которая позволит нам задачу решить ну то есть модели это модель алгоритма который я наиболее понятен с минимальным количеством переменных описывать задачу ну вот рассматривать задачу очевидно что у нас отдельно будут печататься первое и последняя строка и дальше будут свою очередь печататься средние строки и средние строки и очевидно что любая из этих строк будет печататься каким-то единообразным образом так давайте вот как напечатать первую последнюю строчку я думаю здесь понятно давайте рассмотрим а средние строки что мы здесь можем заметить мы с вами здесь можем заметить что у нас расстояние между слэшами вот слэш слэш слэш и бэк слышами каждой строке точнее даже не каждой строки вообще во всех строках одинаковая но вот тут мы можем посчитать какое-то расстояние ну точнее какой там будет сдвиг если это вот допустим 0 1 2 3 4 5 6 то есть каждому шестым символом начиная с какого-то вы будете печатать слэш ну то есть вот какой-то символа кстати да вот символ как мат символ назовем давайте вот позицию этого символа назовем например тёст слэш принципе нормальное название как раз отражает вот вот эта позиция будет слэш то есть для нашего конкретного примера но если вы начинаете с нуля это 0 1 2 3 то есть вот третьим символом мы напечатаем слэш дальше у нас идет плюс 6 то есть если это было три то на девятом символом опять напечатаем слэш то есть это три четыре пять шесть семь восемь девять соответственно плюс еще шесть пятнадцать десять одиннадцать двенадцать тринадцать четырнадцать пятнадцать опять напечатаем слэш значит все слэш аналогично у нас будет фест бэк слэш бэк слэш и вот то что я сказал между символами будет соответственно битвин битвин это вот как раз смещение через которое возникает очередной слэш либо бэк слэш теперь нам нужно зависимости вот от этих параметров в и аж которые нам точнее ашева и которые нам передаются а тут лаяш но неважно в и аж определить вот эти вот значения ну для первой строки есть и ну смысле для первой строки которая содержит эти символы смотрите во многих таких задачах вместо того чтобы строго математически выводить именно какие-то цифры какие-то формулы можно поступить чуть хитрее это будет абсолютно правильно как чуть хитрее значит вот смотрите давайте рассмотрим следующий пример вот что произойдет если мы увеличим аж на единицу ну давайте вот прорисуем и увеличим аж на единицу что произошло с первым символом то есть при увеличении аж на 1 вот ферс слэш ну и соответственно тирк бэк слэш мы увидели что он сдвинулся тоже на 1 значит если у нас где-то есть такая зависимость мы что-то увеличиваем на 1 и при этом какая-то другая величина также увеличивается на 1 мы пока там не выяснили конкретную формулу но совершенно точно это будет некая формула f плюс некий x ну x 1 то же самое с этим будет это будет аж то есть величина которую мы увеличили и вот наш ферс бэк слэш тоже увеличился то есть это будет общая формула аж умножить на 1 ну а 1 я не пишу соответственно плюс некая x 2 вот какие x 1 и x 2 мы сейчас далее выясним так теперь рассматриваем что же вот дальше будет дальше будет следующее вот здесь мы вынуждены будем сместиться на 2 чтобы у нас вот здесь поместилось два вот этих наших символов соответственно соответственно вот эти вот все расстояния они у нас тоже увеличится на 2 на 2 символа и что мы видим что при увеличении h то есть увеличение одной величины на единицу другая величина увеличивается на 2 это означает что у нас общая формула будет вот такая 2h плюс некая x3 вот это совершенно так по-другому быть не может и теперь нам остается вот эти вот x 1 x 2 x 3 найти как мы можем найти просто для конкретного примера подобрать эти x 1 x 2 x 3 и эти значения они будут справедливы и для всех остальных случаев так вот сейчас я увеличил аж аж равно 6 получается так давайте смотреть если будем считать с нуля 0 1 2 3 4 4 то есть четвертый символ когда аж равно 6 все слэш у нас равен 4 означает что вот этот x 1 у нас будет минус 2 1 2 ну точнее 0 1 2 3 4 тут 6 ну вот значит минус 2 соответственно first backslash тут мы с вами в принципе даже могли бы не мучиться просто написать все слэш плюс единица так расстояние вот аж равно 6 и здесь у нас если это допустим 0 1 2 3 4 5 6 7 8 8 то бишь 2 умножить на 6 это 12 а у нас получилось 8 это означает что этот вот x 3 равен на минус 4 то есть вот такая будет форму теперь что мы видим что происходит далее а далее у нас очевидно что при переходе к следующей каждой следующей строке у нас все слэш уменьшается афер бэкслэш наоборот увеличивается но тут вот была позиция мы посчитали 4 станет соответственно 3 потом 2 потом 1 то есть при переходе к новой строке ферс слэш уменьшается единицу а бэкслэш наоборот увеличивается ну и соответственно когда мы будем печатать строчку мы можем ввести следующее обозначение назовем next слэш и next бэкслэш то есть это позиция очередного символа флэш и бэкслэш и действует мы будем следующим образом ну понятно первоначально в каждой строке next равно фиост и и и и получается когда мы очередной символ печатаем например печатаем next слэш то в этот момент мы должны будем к next слэш прибавить битвин ну то есть вот если мы здесь напечатали вот были next слэш у нас был 4 то следующий next слэш будет 4 плюс сколько там мы посчитали 8 до значит если это было 4 5 6 7 8 9 10 11 12 то есть просто прибавляем битвин вот мы с вами придумали такую модель теперь давайте ее просто реализуем у меня тут реализация есть но давайте я буду писать чтобы процесс видели и может быть там что-то себе дополнительно отмечали и так здесь нам проще всего поступить просто запустить цикл который будет там будет там проходить по строкам и так нет здесь начале вот эти вот надо вычислить вот эти формулы которые мы записали это мы можем сделать вот здесь то есть до всех циклов да ну так ну так дальше ну давайте то оставим значит вот это я сделал для того чтобы каждый раз не писать систему а вот принт лэна соответственно у меня появляется новая переменная out которая указывает на тот же самый объект на который указывает поле out модуля систем то есть вот out и система вот теперь это один тот же объект и теперь вместо систем out println я могу просто писать out println вот мы сейчас ниже увидим просто сейчас комментирует для чего мы это сделали так дальше у нас идет соответственно соответственно перебор строк и столбцов мне лично удобнее не знаю как это мне же перебрал ну да все правильно мне удобнее перебирать в данном случае переменными не ай джейк а и и сих где r это номер строки ру а сета соответственно номер столбца полу поэтому я вот буду действовать так значит и r меньше либо равно h r r плюс плюс соответственно внутренний цикл будет у нас перебирать ой соответственно ну или символы в строке ну как больше приятно так точнее даже вот в начале мы с вами внутри внешнего цикла напечатаем точнее проверим если у нас какая-то строка является первой и последней то мы напечатаем первое последнее то мы напечатаем первую последнюю строчку значит если r равно равно нулю либо r равно h минус 1 в этом случае будем печатать последнюю строку конечно можно было бы вот этого точнее код который сейчас будет вот здесь вот где курсор можно было вынести до цикла и после цикла но тогда он бы просто дублировался до цикла и после цикла и и ну кода было бы больше и самое главное было бы дублирование поэтому вот в данном случае я считаю что лучше поступить следующему как здесь так так вот теперь мы вместо систем out пишем out printlm среда нам естественно также подсказывает также как и систем out потому что здесь идет полный такой статический анализ среда понимает что out это объект класса принц 3 мы у него соответствующие методы так ну принт конечно начали print печатаем а звездочку дальше дальше перебираем c с единицы почему снизу потому что вот нулевой символ мы уже напечатали значит c меньше в минус 1 чтобы последний символ напечатать c плюс плюс печатаем соответственно минусик так мы в конце печатаем вот этот вот символ в данном случае println чтобы сделать перевод строки и и вот как раз воспользуемся метод точнее методом операции continue continue это операция которая которая переходят к следующей тракции цикла вот к следующей тракции в данном случае цикла внешнего то бишь мы прибавим r и начнем заново выполнять тело цикла соответственно если мы вот этот вот операции continue вызвали то вот на эту строчку в этой текущей итерации мы уже не попадем то есть первая последняя строка будет вот здесь вот напечатано следственно если мы попали вот сюда то это не первая и не последняя строка значит перед циклом то что вот я говорил присваиваем вот эти значения и и и и и так теперь проходим по а ну кстати да тут тоже наверное можно сделать как присваивать так присвоили также наверное имеет смысл начинать с одного до в минус один в начале здесь напечатаем символ вертикальная черта снизу напечатаем символ также вертикальная черта значит здесь проходим по средним символом вот c у нас как раз соответствует номеру строки соответственно c измеряется в тех же самых единицах начинается также с нуля как вот эти вот наши next slash next backslash значит здесь если у нас не то есть то есть то есть то есть то есть вот про эти символы идем речь если это не слышь не бэкслэш то это пробел поэтому первоначально мы некому символу который будет содержать текущий символ который нужно напечатать точнее переменной присваиваем символ пробел а дальше смотрим если вдруг у нас оказалось что вот очередная позиция равна next slash то в этом случае мы с вами будем печатать символ slash так и next slash как мы сказали увеличим на битвин то же самое абсолютно с backslash он то же самое абсолютно с backslash он обратите внимание что в строчках в том числе точнее когда мы в программе задаем какую-то строку который нам нужно задать backslash в данном случае не строку а символ то нам нужно этот backslash экранировать потому что просто backslash задает некие специальные последовательности которые записываются двумя символами в ходе программы но реально представляют один символ вот в данном случае хотя мы здесь записали два символа это вот как бы символ экранирования сам символ вот задается вторым символом после первого backslash соответственно допустим символ перевода строки был бы вот такой символ перевод символ тупуляции мы задавали бы вот так то есть это один символ но внутри строк в коде программы он записывается через два символа то есть первый символ указывает что это какой-то такой непечатанный непечатаемый символ следующий соответственно символ после backslash как раз определяется что это за непечатаемый символ то есть точнее он может быть и печатаемый но как табуляция но табуляция то вот несколько пробелов так ну там есть какие-то последовательности я знаю совершенно это перевод строки слэш р это возврат каретки кстати windows перевода строк текстов задаются именно двумя символами перевод строки возврат каретки в linux unix одним символом так бывает там еще бы это там что-то по моему он работать не будет но это какой-то звуковой сигнал ну и какие там еще бывают и соответственно просто если мы хотим задать backslash так как сам backslash один используется для от экранирования то backslash он вынуждены сдавать в строке в коде программы именно двумя символами но это вот один backslash так так так так здесь мы тоже все сделали печатаем символ очередной вот который мы вычислили так и вот последнее что мы еще не успели сделать мы сказали что перри при переходе к следующей строке у нас соответственно ферст слэша уменьшается этот backslash увеличивается поэтому здесь мы напечатали перешли к новой строке и ну давайте пространство здесь кстати тоже наверное можно оставить для наглядности значит next slash уменьшается first slash уменьшается backslash backslash соответственно увеличивается так так вот такая получилась программка так это седьмой пример ну вот который мы только что выполнили ой просто 7 7 еще какие-то варианты ну вот вот неважно это наш вариант который только что написали так так так раньше выходим а а а а а а а а а а а а а а а а а а а а а а а а ну конечно а а а а а а а а а а а а а а а а а а а а ну не не а а ну и видно что все работает как мы задумали то есть это достаточно такая не самая тривиальная задача но мы видим когда мы в главе у себя сложили правильную модель то оказалось что ничего сложного в реализации такой программы нет и даже несмотря на то что она вот там занимает сколько 40 строк ну там включая пустые строчки но не суть все достаточно просто то есть потому что мы знаем вначале придумали как мы будем действовать и дальше действуем тут вообще задумываться нигде не надо вообще одинаковые кусочки в общем все у нас получилось так если вопросы какие то есть то задавайте иначе приходим к следующему примеру пока вы там вопросы задаете потом если что отвечу давайте просто рассмотрим что нам нужно в следующем примере сделать так в следующем примере нам нужно напечатать вот такой вот треугольник из символов abc и если мы присмотримся как внутри этого треугольника эти символы повторяются то мы увидим что это просто общая последовательность где вначале abc повторяются по одному разу потом abc стараются и виси по два раза потом и биси выполняется по три раза потом по 4 так далее до тех пор пока полностью не закончится соответственно наш треугольник для условия вот этого да можно было использовать илсов конечно можно было потому что эти условия они у нас как были по один символ либо другой символ одновременно быть не могут поэтому конечно можно было поступить следующим таким же образом как вы предлагаете но я лично уксаде да у меня вот здесь вот лсов написан в том примере который я был а то короче в том который был и который выложен соответственно на муду но понятно что каждый раз когда вы там пишите вы понятно у каждого есть или будет какой-то свой стиль кодирования он там будет плюс минус одинаковые ну в смысле для человека одинаковые то есть одну и ту же программу один тот же человек большой вероятность будет писать каким-то похожим способом но грубо говоря где-то он одну переменную заведет где-то дополнительную переменную заведет где-то вот напишет лс и где-то этот лс и и напишет и так далее в целом я случаев склоняюсь чтобы лс их не писать потому что в данном случае надо можно было написать потому что если лс человек потом другой который то программу читает он будет именно обращать внимание что здесь хотя здесь наверное может быть и действительно имеет смысл лсф написать потому что как раз один на случай он исключает соответственно другой случай а если бы мы здесь написали бы там где-нибудь вот в этом нам здесь не нужно допустим break либо continue то наверное лсф нужно было бы писать но в целом чем меньше вложенных конструкций я программа воспринимается проще с другой стороны в данном случае действительно наверное надо подчеркнуть что либо этот случай либо этот случай но тут вот спорный момент потому что тогда бы по хорошему надо было бы и вот здесь вот чар тоже вот здесь присвоить да вот тогда бы было бы наверное понятно здесь мы просто объявили а здесь в лс присвоили соответственно пустой символ ну как там сейчас я смотрю на это мне кажется это более громоздко поэтому наверное наверное вот такой вариант когда мы присваиваем а начали символ потом проверяем а какие варианты могут быть чтобы этот символ изменить вот без лсф а вот вот прошлый раз мне казалось вот так вот более удобно вот сейчас я смотрю на этот код и мне кажется что вот так вот более так сказать симпатично и понятно может быть завтра или послезавтра я опять лсф напишу в данном короче случае не принципиально так значит следующий пример вот мы кажется такой пример уже с вами рассматривали где формировали такую последовательность это вот пример соответственно 6 061 но только единственно здесь у нас было не и и бисе а и бисе динова сама последовательность была одинаковая поэтому мы с вами можем вот этот вот пример а соответственно 6 2 который у нас был переделать в пример а пример пример 8 ну и опять же тут у меня такие примеры естественно реализованные сейчас мы это с вами переделаем еще раз для того чтобы вы видели код вот значит пример 8 значит примере 8 нам задается page значит здесь в этом примере я напомню мы вот вот все последовательности а которые у нас есть есть разделили на фрагменте вот состоящие из трех трех вот символов в смысле трех а сейчас я разделю будет понятно то есть внешний цикл у нас будет перебирать вот эти фрагменты а внутренний цикл будет перебирать буквы а самый самый внутренний уже будет повторение повторение каждой буквы так значит вот внешний цикл он перебирает вот эти вот последовательности и в данном случае переменная repeat она определяет сколько раз каждый символ мы будем повторять дальше вложенный цикл перебирает символы от и до си и последний я самый самый вложенный цикл то есть 3 по вложенности перебирает нужное количество повторений каждого символа в данном случае я использовал к потому что потому что потому что собственно вот как я говорил если вложенные циклы часто используют переменные а и джей и кей соответственно но в данном случае вместо а и джей нам проще было использовать символы точнее переменные которые имеют какую-то смысловую нагрузку в названии но вот третий цикл цикл здесь просто простой перебор но можно наверное ай было бы использовать но вроде как ай должен быть для внешнего цикла поэтому вот буква к так ну понятно здесь можно было абсолютно что угодно любой символ написать и все было бы правильно так значит здесь мы считали символы которые всего напечатано вот в предыдущем примере и как только напечатаем нужное количество символов мы соответственно завершали функцию теперь мы будем действовать другим способом у нас будет переменные чтобы я соответственно одинаково их называл появится следующие переменные так вот это в общем а переменная которая будет определять длину строки роллэн первоначально длина строки у нас будет где картинка первоначальная длина строки будет равна высоте нашего треугольника но мы можем проверить что если мы какой-нибудь простенький пример нарисуем то высотой 3 мы видим что в первой строке у нас количество символов равно высоте нашей фигуры соответственно если мы добавляем высоту то увеличивается на единицу поэтому вот по той же самой нашей нашему принципу что если что-то преувеличение также увеличивается на единицу то это будет формула x плюс какой-то вот перемещение в данном случае плюс 0 поэтому просто равно h просто равно h в начале так теперь вот этот вот символ который будет подсчитывать сколько мы напечатали символов в очередной строке ну хотя да его нам тоже надо здесь объявить внутри мы его как раз объявить не можем потому что действия вот этого это переменная распространяется на все циклы так ну и понятно первоначально мы напечатали символов в строке 0 пока мы еще ничего не напечатали так теперь теперь мы будем проверять если вдруг мы строки в строки напечатали количество символов которые необходимо было напечатать в этой строке то в этом случае мы выполним перевод курсора на новую строчку то есть разорвем строку дальше очевидно что при переходе к новой строке у нас количество символов которые мы будем печатать в следующей строке уменьшится на 1 то есть уменьшится длина строки уменьшится длина строки значит уменьшится длина строки и конечно же мы должны сбросить вот этот вот счетчик который печатает у нас который подсчитывает количество символов начатанных строке так и что здесь может произойти а здесь у нас еще может произойти следующая конструкция так вот когда мы печатаем очередной символ мы должны принтер тэнроу очевидно увеличить так последнее что мы не сделали у нас все вот эти вот циклы они у нас никогда не прервутся так ну и собственно что вот здесь вот можно вставить следующую конструкцию если какой-то момент при уменьшении количество символов которые мы должны будем напечатать следующей строке вот это количество символов станет равно нулем то очевидно что всю фигуру мы напечатали уже и нам просто нужно выйти из цикла то есть вот такой получился код исправленной из примера 62 и сейчас мы опять же опять же проверим как это все работает ну тут у нас сколько-то раз там чего-то напечатает сейчас уже сотру так и пример 8 блин так смотрим и бисе и бисе по два раза и бисе по три раза по 4 по 5 и так далее ну то есть все работает можно естественно запустить с каким-то другим количеством символов но очевидно что здесь также все будет работать вот собственно пример опять же мы придумали некую модель модель вот которая состоит из внешних циклов которые у нас будут обеспечивать правильное повторение соответственно нужных символов и дальше вот в рамках вот этих циклов еще добавили подсчет символов которые печатаются в каждой строке ну и в общем то переменных для символов символов количество символов каждой строки ну и вот вот это вот вот этот фрагмент обеспечивает нам корректный перевод строки так теперь смотрите вообще говоря ну вот нет пример так какое решение кажется более удачным но чисто теоретически можно написать решение которое будет перебирать строки и столбцы а уже внутри будет подсчитывать символы то есть можно было бы поступить следующим образом сейчас мы например тоже рассмотрим но вот это я считаю вариант более сложный ну по крайней мере для меня более сложный может быть кому-то из вас наоборот покажется более простым простым в этом примере мы будем перебирать строки то есть вот то что вроде на первый взгляд более очевидно перебираем строки от 0 до а ваш внутри перебираем символы в строке символов строки первоначально у нас будет меньше либо равно либо равно нет а перебираем строки строки да лучше нам перебирать их от короче от h блин так тоже плохо получается давайте строки будем перебирать обычным способом а здесь введем собственно размер строки да то есть некий лэн который присвоим в данном случае аж минус r плюс нет плюс не нужно то есть когда у нас r будет равно нулю соответственно для для первой строки то аж минус r будет h минус 0 равно аж то есть длина будет правильная для следующей строки она уменьшится на единицу и так далее так ну либо мы могли бы вот этот лэн не вводить а просто h минус r записать вот сюда да то есть мы перебираем c от 0 до h минус r здесь соответственно строгое неравенство ну давайте ладно лэна ставим все таки я сам говорю что надо стараться писать программы более понятными лишние символы в общем то не ожалить лишние переменные если они повышают понимание программ поэтому будет будет вот таким вот образом так и теперь нам нужно как-то вот если в этом примере помимо вот этой логике циклов мы придумали как бы параллельную логику с подсчетом количество символов строки и символов строки а здесь нам вот помимо этой логике перебора символов перебора строк и количество символов строки надо придумать логику с логику с логику с символами окно и чтобы просто у меня в примерах не отличалась название переменных и сейчас все скопируем значит то введем следующее понятие значит репетчар сколько каждый символ должен повторяться первоначально символы у нас будут повторяться каждый конкретный символ один раз так принтер чара это будет переменная которая будет подсчитывать сколько у нас каждый конкретный символ повторился поэтому поэтому первоначально это значение 0 1 символ и которым вы чатать он еще ни разу не повторился ну и собственность сам символ начальна это символ ведь что мы теперь здесь делаем смотрим если вдруг оказалось так что количество напечатанных конкретных символов у нас совпало с а репет ну с тем количеством символов которые мы должны были повторить ну или как может быть давайте ну ладно пусть остается так то в этом случае очевидно что нам нужно изменить символ на следующий то есть был и мы поменяли на бе был и поменяли на сину тут может оказаться так что после такого изменения у нас этот символ станет равен и то есть то есть получается мы уже напечатали соответствующий я соответствующий фрагмент и нам нужно что сделать нам нужно символ сбросить и и увеличить количество повторений каждого символа вот это мы здесь делаем так если равен дим то в этом случае ну кстати да вот здесь прибавили символ в любом случае мы сбрасываем количество напечатанных конкретных символов в ноль в ноль значит дальше есть давайте даже начали наверное сбросим потом увеличим значит если оказался символ дитом и меняем на символ эй ой меняем и при этом увеличиваем количество количество символов которые мы должны вот в следующий блоке из символов и бисе ну то есть для каждого символа так так так чем он тут у нас недоволен а ну понятно чем недоволен потому что здесь вот мы какие-то действия выполнили а потом естественно мы должны будем напечатать очередной я так а аут я чуто тут ну аут я не использую ну ладно а чатаем очередной символа раз и соответственно после вложенного цикла который у нас перебирает символы в конкретной строке мы должны напечатать перевод строки так что опять так а репетчар один принтер чар 0 ахаха когда мы напечатали символ мы должны естественно вот этот вот увеличить а вот и вот кстати обратите внимание видите то есть если вы видите что у вас среда подсвечивает какой-то фрагмент вот таким каким-то бежевым то надо действительно разобраться в чем причина бывает конечно причина в том что вам предлагают какую-то оптимизацию как код можно записать короче но при этом код у вас правильный и даже более наглядный в этом случае нужно игнорировать но очень часто вот такие такие такие подсказки они действительно показывают на какую-то проблему в вашем коде прям вот проблему логическую поэтому просто игнорировать нельзя нужно обязательно разобраться в чем причина почему вам всегда пытается что-то подсказать и уже тогда либо исправить ошибку чаще всего либо игнорировать в моем случае была ошибка в том что напечатав символ я не увеличил переменную количество напечатанных символов именно конкретных символов вот поэтому здесь условия постоянно было истина по моему постоянно поэтому поэтому программа программе была ошибка так ну и вот этот второй вариант рассматриваем вариант тоже работает верно конечно кому как нравится мне нравится больше первый вариант потому что хотя в плюс минус они в общем то похожи по сложности так теперь идем дальше могут примеры даст какие то вопросы есть в этом пишите так можно для условий было использовать а это уже было вопрос был так теперь давайте рассмотрим следующие примеры которые у нас будут соответственно 9 10 и 11 пример с елочкой вот я вот их перед лекцией сегодня придумал значит пример с елочкой в данном случае n у нас будет задавать не высоту а количество вот таких вот секций которые нужно будет напечатать в данном для конкретном примере это n равно 3 ну и соответственно пенечек у нас сюда будет одинаковый так рассматриваем этот пример значит в этом примере мы можем ну и кстати во многих примерах вот в пятой задаче вы на принципы обращайте внимание как мы сейчас будем составлять задача и так определима некую функцию которую у нас будет печатать очередную строку вот в этой фигуре за исключением пинька значит даже мы можем не так поступнул да ладно так будем поступать что мы здесь видим вот если мы любую строчку рассмотрим то у нас здесь будет какое-то количество пробелов какое-то количество пробелов до это что это до слыша дальше какое-то количество пробелов включая 0 точнее даже не пробелов а каких-то символов вот в данном случае эти символы будут пробелы между слышим и бэк слышим и вот в этом случае это будут подчеркивать и потом печатаем бэкслэш то есть для такой функции нам нужно определить сколько пробелов в начале и сколько соответственно символов между слэш бэкслэш и собственно какой-то символ давайте мы такую функцию определим ну давайте сейчас пример пример 9 и так и в рамках этого примера 9 и в рамках этого примера в рамках этого примера и опишем функцию которая у нас будет печатать очередную строку количество символов в начале ну эти символы у нас пробелы поэтому не будем указывать значит количество символов в начале а ну эти символы у нас пробелы поэтому не будем указывать значит количество символов а между и получается символа который будет точнее не чар давайте мы его чтобы было понятно битвин чара зовем и какой символ соответственно между нечего так ну и реализация кстати да реализация смотрите вот здесь нам еще наверное будет полезна функция которая просто печатает какой-то символ какое-то количество раз понятно что у нас если бы мы писали код промышленный дом то мы бы с вами скорее всего просто бы генерировали строчку с помощью соответственно функции repeat но в данном случае чтобы соответствовать по условию задачи чтобы нигде там никакие строки не использовать у нас будет функция которая у нас будет печатать н символов и каких конкретно символов мы укажем так и тут у нас просто будет цикл мы сейчас с вами создаем некий инструмент который мы сможем использовать в реализации вот и вспомогательной функции потом основной функции для печати пенька тоже будем использовать значит функция которая просто н раз печатает указанный символ ой чуть я тут не то пишу собственно во многих задачах вот именно во многих пятых задачах вариантах пятой задачи вот такая функция будет крайне полезна и печатаем очередной символ так получается здесь мы с помощью вот этой функции напечатаем напечатаем ну и давайте да чтобы у нас все таки были более человеческие названия вифок каунт напечатаем пробелов потом напечатаем слэш дальше битвин каунт напечатаем указанный символ и и в конце здесь вот print здесь соответственно println напечатаем бэкслэш и так такая функция готова то есть она может любую из этих строк напечатать теперь нужно собственно составить модель которая будет все это печатать и так и так ну очевидно что мы можем вот вначале перебирать а и будет перебирать вот соответствующую соответствующий треугольник в в нашей елочке внешний цикл ой тут тут да не тут смешняш н и и и и и и и и и и и и и и и и и и и и и и меньше n и и плюс плюс так теперь давайте мы для каждого вот этого фрагмента определим высоту высота у нас будет равна собственно высота она и будет равна и и и и и и и и и и и и и и и и и и и и и и и и и и и и и и и и здесь мы когда перебираем нужные строчки естественно будем вызывать вот эту функцию собственно для этого мы ее и написали так кстати да сам на вас ругаюсь а написал неверно в данном случае ладно вот этот вот sample 9 может быть оправдан а вот здесь соответственно будет print roll так а теперь мы должны получается определить какое количество у нас будет символов перед в зависимости от того в зависимости от ай и джей так и кстати не только от ай и джей получается а еще и от м то есть вот а и джей н сейчас посмотрим какой комбинации будет у нас определять какое количество вот здесь вот символов мы должны напечатать так и опять же давайте мы будем составлять формулу по какому-то там принципу а умножить на ай плюс б умножить на джей плюс я так думаю что так будет сейчас вот заодно узнаем плюс c умножить на н так ну и также это предлагал чтобы все не говорить хотя можно конечно вывести не так сложно вот если мы увеличим а чем а тем вот берем каждый раз первую строчку собственно ничего у нас не меняется да нет меняется меняется если бы у нас смотрите если бы у нас елочка была из двух секций то очевидно что вот здесь вот было бы вот так да то есть вот первый символ ну неважно какой символ там 1 2 символ он был бы ближе то есть получается вот при увеличении н вот этот коэффициент здесь единица то есть увеличили на единицу сдвинули на 1 поэтому здесь будет плюс м значит с одним коэффициентом определились давайте я так буду писать здесь c c равно единице и и пока общая формула выглядит плюс м дальше дальше при увеличении номера строки а ну точнее до номера строки номер строки это нас джей то есть вот это была первая строчка это следующая строчка при увеличении номера строки у нас расстояние количество пробелов до 1 слыша но уменьшается поэтому б мы возьмем минус единицу значит и общая формула будет минус чей так и теперь ай ай у нас это собственно секция так а вот с каждой секции у нас получается ничего не меняется то есть вот для этого первого символа что здесь он что здесь короче вот похоже вот такая формула то есть а будет равно 0 и общих формула получается n минус чей ну тут сейчас проверим может быть я конечно тоже путаю n минус джей печатаем в начале пробелов дальше дальше ну дальше чуть более очевидно собственно количество будет определяться пробелов точнее символов для вот при увеличении джей получается номера строки в конкретной секции у нас вот здесь вот между было 0 символов здесь стало два символа здесь того четыре символа то есть два раза увеличивается поэтому мы просто можем а джей умножить на 2 или 2 ну ну ну джей лучше джей умножить на 2 то есть так как джей первоначально у нас равно нулю поэтому вначале мануле напечатаем символов потом следующий потом следующий так далее и теперь нам нужно определить какой символ мы будем печатать а символ мы с вами будем печатать либо пробел либо соответственно подчеркивание подчеркивание мы будем печатать в момент когда печатаем вот последнюю итерацию поэтому здесь воспользуемся как раз тернарным оператором если у нас джей равно h минус 1 то в этом случае печатаем символа подчеркивание то последний в противном случае печатаем пробел так давайте сейчас вызовем этот метод проверим что у нас хотя бы елочка правильно напечаталась или неправильно потом уже напечатаем пенек и так а если что здесь я забыл количество нужно увеличить при печати здесь нужно перебирать нет секция мы правильно так этом точно 3 прием значит перебираем секции а ну вот это же высота высота будет а и плюс 1 для естественно вот поэтому у нас не ошибка vibrant как он скачивается says и и и и и и и и и и и ага и тут все-таки появился лишний символ это говорит о том что вот здесь вот я что-то неверное посчитал а наверное я верно посчитал но я просто что не учел что здесь еще будет какой-то коэффициент плюс d а d в данном случае вот как раз мы вывели такую формулу n минус j ну и в общем там у нас окажется что d минус 1 и поэтому минус 1 вот у нас получилось правильная елочка осталось напечатать пенек значит пенек если мы увеличиваем количество секции на одну то вот ширина самой нижней секции увеличивается на 2 и соответственно пенек сдвигается на единицу то есть при увеличении количество секций на единицу пенек тоже сдвигается на единицу и вот для трех здесь у нас будет раз-два символа то есть очевидно что количество пробелов которым должны напечатать для допинька это будет n минус 1 для этого у нас как раз с вами есть функция вот это вот который мы напечатаем количество так там первое м минус 1 пробелов у и в конце соответственно принт лн виде строки пенек вот наша соответственно елочка ну если увеличим там тоже все будет правильно можете не сомневаться значит видите тоже вроде как кажется с первого раза задача довольно сложная для вашего уровня дам то есть для студентов 1 курс который только начали изучать программирование с другой стороны вот эта функция прям совсем очевидно и она нам сильно облегчает жизнь то есть смотрите вот если бы этой функции не было мы бы вот здесь написали цикл который загромождал бы код и соответственно в нем терялась не воспринималась бы суть значит вот был бы цикл соответственно здесь был цикл ну и вот все получилось достаточно ровненько и опять же нам сильно помогла функция которую мы придумали которая нам печатает любую строчку причем мы ее как вы видите смогли определенным образом обобщить чтобы печатать и последнюю секцию каждая точнее последнюю строку каждой секции так и вот все остальные строчки то есть вот передавая именно тот символ который будет там в конце во многих задачах именно удобно какую-то такую функцию придумать не всегда но удобно так следующий пример следующий пример да если вам что-то непонятно вы спрашиваете потому что мне тут все очевидно но вам может быть не очевидно ну и вот да еще раз выскажу мысль что не надо всегда делать лоб пытайтесь придумать какие-то себе инструменты для решения задачи и потом уже с этим с помощью этих инструментов вас задача будет решаться проще в данном случае у меня вот было в качестве таких инструментов вот эти вот две функции но эта функция прям совсем универсальная а это под конкретную задачу вот и вот эти вот формулы можно было конечно строго вывести но опять же очень часто если вы поймете принцип как у нас какие-то количество какие-то переменные как они меняются при изменении других переменных то можно просто ну как не совсем уходить конечно в общем короче подобрать нужную комбинацию нужную формулу вместо того чтобы строго выводить где-то она прям совсем очевидно где-то вот можно как я действовал куда брать так следующий пример следующий пример которому рассмотрим это печать вот такой вот такого прямоугольника с орнаментом значит это пример будет номер 10 тоже он похож на часть примеров которые у вас были но здесь мы применим другой принцип вот в отличие от хотя мы конечно могли бы и там же также поступить вот точнее в этом десятом примере также поступить то есть описать функцию которая будет печатать ну кстати да давайте вот пример он как раз подходит решим двумя способами значит способ номер один и способ номер два значит здесь у нас задается высота и задается ширина так способ номер один будем испугнуть да собственно комментарий был понятно что мы сделаем итак опять же вот давайте решим первым способом когда составим некую функцию которая будет печатать нам очередную строчку вот для для на эту функцию мы можем ой на эту фигуру мы можем придумать универсальную функцию которая нам будет печатать все строчки включая первую последнюю значит в эту функцию мы будем передавать очевидно ширину а также будем передавать три символа первый символ и последний и дальше первый символ и соответственно второй символ ну то есть будем передавать некую границу символ границы и дальше 1 и 2 символ вот в чередующейся последовательности символов значит для первой строки границы у нас будет звездочка 1 и 2 символ будут минусики для всех остальных строк это будут в качестве границы вертикальная черта качестве 1 и 2 символ